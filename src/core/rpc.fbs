// Copyright 2017 Alexander Gallego
//

namespace smf.rpc;

/// \brief: headers that are stored in an int
/// so they need to be inclusive. That is, you can turn on
/// many flags at the same time, i.e.: enable checksum and
/// have the payload be zlib compressed.
///
enum compression_flags:byte {
  /// \brief compression not set
  none,
  /// \brief useful for preventing outgoing filters from
  /// enabling some compression
  disabled,
  /// \brief zstd compression
  zstd,
  /// \brief lz4 compression
  lz4
}
enum header_bitflags:byte (bit_flags) {
  // by default bit flags start at _NONE=0
  has_dynamic_headers
}

/// \brief: header parsed by rpc engine
/// must be sizeof()'able
/// that is, must be a struct in fbs language
///
/// layout
/// [
///               8bits(compression) + 8bits(bitflags) + 16bits(session) +
///               32bits(size) +
///               32bits(checksum) +
///               32bits(meta)  +
///               32bits(dynamic_headers_size)
/// ]
/// total = 160bits == 20bytes
///
struct header {
  compression:    compression_flags;
  bitflags:       header_bitflags;
  /// 16 bits for storing the actual session id.
  /// used for streaming client and slot allocation
  session:        ushort;
  /// size of the next payload
  size:           uint;
  /// currently we use (xxhash64 & UINT32_MAX)
  checksum:       uint;
  /// \brief used for sending and receiving, read carefully.
  ///
  /// Receiving:
  ///
  /// Uses the same as HTTP status - on the receiving end
  /// We don't want to pay the cost of parsing a header
  /// On every response as does HTTP. std::to_string and std::stol()
  /// are needlesly expensive
  ///
  /// Sending:
  ///
  /// Used with the xor hash of Service::ID() ^ Service::Method::ID()
  /// This is how the server multiplexer figures out what function pointer
  /// to call
  ///
  meta: uint;
  /// \brief size of dynamic_headers struct if bit
  // @bitflags::header_bit_flags_has_dynamic_headers is se
  dynamic_headers_size: uint;
}

table header_kv {
  /// implementations are strongly encouraged to sort on hdr_key
  /// use with CreateVectorOfSortedTables<> instead of the CreateVector
  hdr_key: string (key);
  hdr_value: [byte];
}
/// \brief user sparingly. Plain text strings are expensive in byte-count.
table dynamic_headers {
  values: [header_kv];
}

/// \brief, useful when the type is empty
/// i.e.: void foo();
/// rpc my_rpc { null_type MutateOnlyOnServerMethod(int); }
///
table null_type {}

/// ---------- Internal protocols below
struct failure_spec {
  delay_duration_ms: uint;
  delay: bool;
  terminate: bool;
  exception: bool;
}