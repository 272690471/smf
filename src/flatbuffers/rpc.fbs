namespace smf.fbs.rpc;

/// \brief: headers that are stored in an int
/// so they need to be inclusive. That is, you can turn on
/// many flags at the same time, i.e.: enable crc32 checks and
/// have the payload be zlib compressed.
///
enum Flags:uint (bit_flags) {
  SNAPPY,
    ZLIB,
  VERIFY_PAYLOAD
}

/// \brief: header parsed by rpc engine
/// must be sizeof()'able
/// that is, must be a struct in fbs language
///
struct Header {
  size: uint;
  flags: Flags = 0;
  crc32: uint;
}

/// \brief: Payload needs to be a table because internally
/// we actually don't hold a pointer to the RPC table, we
/// construct the header from the socket and then construct
/// the payload from the socket. So we need a fbs table to wrap
/// the byte array of the body of the request.
///
/// The idea here is that the `body' will actually be another flatbuffer
/// or any other protocol, so a byte array is the lowest abstraction
///
table Payload {
  body: [ubyte];
}

/// \brief: how the nodes communicate with one another
/// FIXME(agallego): - experiment if you can just send an RPC or if you have to
/// desugar it into 2 buffers. That is, write the header and then write the
/// payload
table RPC {
  header: Header;
  payload: Payload;
}

root_type RPC;
