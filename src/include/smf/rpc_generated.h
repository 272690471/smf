// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RPC_SMF_RPC_H_
#define FLATBUFFERS_GENERATED_RPC_SMF_RPC_H_

#include "flatbuffers/flatbuffers.h"

namespace smf {
namespace rpc {

struct header;

struct header_kv;
struct header_kvT;

struct dynamic_headers;
struct dynamic_headersT;

struct null_type;
struct null_typeT;

struct failure_spec;

bool operator==(const header &lhs, const header &rhs);
bool operator==(const header_kvT &lhs, const header_kvT &rhs);
bool operator==(const dynamic_headersT &lhs, const dynamic_headersT &rhs);
bool operator==(const null_typeT &lhs, const null_typeT &rhs);
bool operator==(const failure_spec &lhs, const failure_spec &rhs);

inline const flatbuffers::TypeTable *headerTypeTable();

inline const flatbuffers::TypeTable *header_kvTypeTable();

inline const flatbuffers::TypeTable *dynamic_headersTypeTable();

inline const flatbuffers::TypeTable *null_typeTypeTable();

inline const flatbuffers::TypeTable *failure_specTypeTable();

/// \brief: headers that are stored in an int
/// so they need to be inclusive. That is, you can turn on
/// many flags at the same time, i.e.: enable checksum and
/// have the payload be zlib compressed.
///
enum compression_flags {
  /// \brief compression not set
  compression_flags_none = 0  /// \brief useful for preventing outgoing filters from
  /// enabling some compression
,
  compression_flags_disabled = 1  /// \brief zstd compression
,
  compression_flags_zstd = 2  /// \brief lz4 compression
,
  compression_flags_lz4 = 3,
  compression_flags_MIN = compression_flags_none,
  compression_flags_MAX = compression_flags_lz4
};

inline const compression_flags (&EnumValuescompression_flags())[4] {
  static const compression_flags values[] = {
    compression_flags_none,
    compression_flags_disabled,
    compression_flags_zstd,
    compression_flags_lz4
  };
  return values;
}

inline const char * const *EnumNamescompression_flags() {
  static const char * const names[] = {
    "none",
    "disabled",
    "zstd",
    "lz4",
    nullptr
  };
  return names;
}

inline const char *EnumNamecompression_flags(compression_flags e) {
  if (e < compression_flags_none || e > compression_flags_lz4) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamescompression_flags()[index];
}

enum header_bitflags {
  header_bitflags_has_dynamic_headers = 1,
  header_bitflags_NONE = 0,
  header_bitflags_ANY = 1
};

inline const header_bitflags (&EnumValuesheader_bitflags())[1] {
  static const header_bitflags values[] = {
    header_bitflags_has_dynamic_headers
  };
  return values;
}

inline const char * const *EnumNamesheader_bitflags() {
  static const char * const names[] = {
    "has_dynamic_headers",
    nullptr
  };
  return names;
}

inline const char *EnumNameheader_bitflags(header_bitflags e) {
  if (e < header_bitflags_has_dynamic_headers || e > header_bitflags_has_dynamic_headers) return "";
  const size_t index = static_cast<int>(e) - static_cast<int>(header_bitflags_has_dynamic_headers);
  return EnumNamesheader_bitflags()[index];
}

/// \brief: header parsed by rpc engine
/// must be sizeof()'able
/// that is, must be a struct in fbs language
///
/// layout
/// [
///               8bits(compression) + 8bits(bitflags) + 16bits(session) +
///               32bits(size) +
///               32bits(checksum) +
///               32bits(meta)  +
///               32bits(dynamic_headers_size)
/// ]
/// total = 160bits == 20bytes
///
FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) header FLATBUFFERS_FINAL_CLASS {
 private:
  int8_t compression_;
  int8_t bitflags_;
  uint16_t session_;
  uint32_t size_;
  uint32_t checksum_;
  uint32_t meta_;
  uint32_t dynamic_headers_size_;

 public:
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "smf.rpc.header";
  }
  header() {
    memset(this, 0, sizeof(header));
  }
  header(compression_flags _compression, header_bitflags _bitflags, uint16_t _session, uint32_t _size, uint32_t _checksum, uint32_t _meta, uint32_t _dynamic_headers_size)
      : compression_(flatbuffers::EndianScalar(static_cast<int8_t>(_compression))),
        bitflags_(flatbuffers::EndianScalar(static_cast<int8_t>(_bitflags))),
        session_(flatbuffers::EndianScalar(_session)),
        size_(flatbuffers::EndianScalar(_size)),
        checksum_(flatbuffers::EndianScalar(_checksum)),
        meta_(flatbuffers::EndianScalar(_meta)),
        dynamic_headers_size_(flatbuffers::EndianScalar(_dynamic_headers_size)) {
  }
  compression_flags compression() const {
    return static_cast<compression_flags>(flatbuffers::EndianScalar(compression_));
  }
  void mutate_compression(compression_flags _compression) {
    flatbuffers::WriteScalar(&compression_, static_cast<int8_t>(_compression));
  }
  header_bitflags bitflags() const {
    return static_cast<header_bitflags>(flatbuffers::EndianScalar(bitflags_));
  }
  void mutate_bitflags(header_bitflags _bitflags) {
    flatbuffers::WriteScalar(&bitflags_, static_cast<int8_t>(_bitflags));
  }
  /// 16 bits for storing the actual session id.
  /// used for streaming client and slot allocation
  uint16_t session() const {
    return flatbuffers::EndianScalar(session_);
  }
  void mutate_session(uint16_t _session) {
    flatbuffers::WriteScalar(&session_, _session);
  }
  /// size of the next payload
  uint32_t size() const {
    return flatbuffers::EndianScalar(size_);
  }
  void mutate_size(uint32_t _size) {
    flatbuffers::WriteScalar(&size_, _size);
  }
  /// currently we use (xxhash64 & UINT32_MAX)
  uint32_t checksum() const {
    return flatbuffers::EndianScalar(checksum_);
  }
  void mutate_checksum(uint32_t _checksum) {
    flatbuffers::WriteScalar(&checksum_, _checksum);
  }
  /// \brief used for sending and receiving, read carefully.
  ///
  /// Receiving:
  ///
  /// Uses the same as HTTP status - on the receiving end
  /// We don't want to pay the cost of parsing a header
  /// On every response as does HTTP. std::to_string and std::stol()
  /// are needlesly expensive
  ///
  /// Sending:
  ///
  /// Used with the xor hash of Service::ID() ^ Service::Method::ID()
  /// This is how the server multiplexer figures out what function pointer
  /// to call
  ///
  uint32_t meta() const {
    return flatbuffers::EndianScalar(meta_);
  }
  void mutate_meta(uint32_t _meta) {
    flatbuffers::WriteScalar(&meta_, _meta);
  }
  /// \brief size of dynamic_headers struct if bit
  uint32_t dynamic_headers_size() const {
    return flatbuffers::EndianScalar(dynamic_headers_size_);
  }
  void mutate_dynamic_headers_size(uint32_t _dynamic_headers_size) {
    flatbuffers::WriteScalar(&dynamic_headers_size_, _dynamic_headers_size);
  }
};
FLATBUFFERS_STRUCT_END(header, 20);

inline bool operator==(const header &lhs, const header &rhs) {
  return
      (lhs.compression() == rhs.compression()) &&
      (lhs.bitflags() == rhs.bitflags()) &&
      (lhs.session() == rhs.session()) &&
      (lhs.size() == rhs.size()) &&
      (lhs.checksum() == rhs.checksum()) &&
      (lhs.meta() == rhs.meta()) &&
      (lhs.dynamic_headers_size() == rhs.dynamic_headers_size());
}

/// ---------- Internal protocols below
FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) failure_spec FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t delay_duration_ms_;
  uint8_t delay_;
  uint8_t terminate_;
  uint8_t exception_;
  int8_t padding0__;

 public:
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "smf.rpc.failure_spec";
  }
  failure_spec() {
    memset(this, 0, sizeof(failure_spec));
  }
  failure_spec(uint32_t _delay_duration_ms, bool _delay, bool _terminate, bool _exception)
      : delay_duration_ms_(flatbuffers::EndianScalar(_delay_duration_ms)),
        delay_(flatbuffers::EndianScalar(static_cast<uint8_t>(_delay))),
        terminate_(flatbuffers::EndianScalar(static_cast<uint8_t>(_terminate))),
        exception_(flatbuffers::EndianScalar(static_cast<uint8_t>(_exception))),
        padding0__(0) {
    (void)padding0__;
  }
  uint32_t delay_duration_ms() const {
    return flatbuffers::EndianScalar(delay_duration_ms_);
  }
  void mutate_delay_duration_ms(uint32_t _delay_duration_ms) {
    flatbuffers::WriteScalar(&delay_duration_ms_, _delay_duration_ms);
  }
  bool delay() const {
    return flatbuffers::EndianScalar(delay_) != 0;
  }
  void mutate_delay(bool _delay) {
    flatbuffers::WriteScalar(&delay_, static_cast<uint8_t>(_delay));
  }
  bool terminate() const {
    return flatbuffers::EndianScalar(terminate_) != 0;
  }
  void mutate_terminate(bool _terminate) {
    flatbuffers::WriteScalar(&terminate_, static_cast<uint8_t>(_terminate));
  }
  bool exception() const {
    return flatbuffers::EndianScalar(exception_) != 0;
  }
  void mutate_exception(bool _exception) {
    flatbuffers::WriteScalar(&exception_, static_cast<uint8_t>(_exception));
  }
};
FLATBUFFERS_STRUCT_END(failure_spec, 8);

inline bool operator==(const failure_spec &lhs, const failure_spec &rhs) {
  return
      (lhs.delay_duration_ms() == rhs.delay_duration_ms()) &&
      (lhs.delay() == rhs.delay()) &&
      (lhs.terminate() == rhs.terminate()) &&
      (lhs.exception() == rhs.exception());
}

struct header_kvT : public flatbuffers::NativeTable {
  typedef header_kv TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "smf.rpc.header_kvT";
  }
  seastar::sstring hdr_key;
  std::vector<int8_t> hdr_value;
  header_kvT() {
  }
};

inline bool operator==(const header_kvT &lhs, const header_kvT &rhs) {
  return
      (lhs.hdr_key == rhs.hdr_key) &&
      (lhs.hdr_value == rhs.hdr_value);
}

struct header_kv FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef header_kvT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return header_kvTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "smf.rpc.header_kv";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HDR_KEY = 4,
    VT_HDR_VALUE = 6
  };
  /// implementations are strongly encouraged to sort on hdr_key
  /// use with CreateVectorOfSortedTables<> instead of the CreateVector
  const flatbuffers::String *hdr_key() const {
    return GetPointer<const flatbuffers::String *>(VT_HDR_KEY);
  }
  flatbuffers::String *mutable_hdr_key() {
    return GetPointer<flatbuffers::String *>(VT_HDR_KEY);
  }
  bool KeyCompareLessThan(const header_kv *o) const {
    return *hdr_key() < *o->hdr_key();
  }
  int KeyCompareWithValue(const char *val) const {
    return strcmp(hdr_key()->c_str(), val);
  }
  const flatbuffers::Vector<int8_t> *hdr_value() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_HDR_VALUE);
  }
  flatbuffers::Vector<int8_t> *mutable_hdr_value() {
    return GetPointer<flatbuffers::Vector<int8_t> *>(VT_HDR_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_HDR_KEY) &&
           verifier.VerifyString(hdr_key()) &&
           VerifyOffset(verifier, VT_HDR_VALUE) &&
           verifier.VerifyVector(hdr_value()) &&
           verifier.EndTable();
  }
  header_kvT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(header_kvT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<header_kv> Pack(flatbuffers::FlatBufferBuilder &_fbb, const header_kvT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct header_kvBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hdr_key(flatbuffers::Offset<flatbuffers::String> hdr_key) {
    fbb_.AddOffset(header_kv::VT_HDR_KEY, hdr_key);
  }
  void add_hdr_value(flatbuffers::Offset<flatbuffers::Vector<int8_t>> hdr_value) {
    fbb_.AddOffset(header_kv::VT_HDR_VALUE, hdr_value);
  }
  explicit header_kvBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  header_kvBuilder &operator=(const header_kvBuilder &);
  flatbuffers::Offset<header_kv> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<header_kv>(end);
    fbb_.Required(o, header_kv::VT_HDR_KEY);
    return o;
  }
};

inline flatbuffers::Offset<header_kv> Createheader_kv(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> hdr_key = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> hdr_value = 0) {
  header_kvBuilder builder_(_fbb);
  builder_.add_hdr_value(hdr_value);
  builder_.add_hdr_key(hdr_key);
  return builder_.Finish();
}

inline flatbuffers::Offset<header_kv> Createheader_kvDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *hdr_key = nullptr,
    const std::vector<int8_t> *hdr_value = nullptr) {
  auto hdr_key__ = hdr_key ? _fbb.CreateString(hdr_key) : 0;
  auto hdr_value__ = hdr_value ? _fbb.CreateVector<int8_t>(*hdr_value) : 0;
  return smf::rpc::Createheader_kv(
      _fbb,
      hdr_key__,
      hdr_value__);
}

flatbuffers::Offset<header_kv> Createheader_kv(flatbuffers::FlatBufferBuilder &_fbb, const header_kvT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct dynamic_headersT : public flatbuffers::NativeTable {
  typedef dynamic_headers TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "smf.rpc.dynamic_headersT";
  }
  std::vector<std::unique_ptr<header_kvT>> values;
  dynamic_headersT() {
  }
};

inline bool operator==(const dynamic_headersT &lhs, const dynamic_headersT &rhs) {
  return
      (lhs.values == rhs.values);
}

/// \brief user sparingly. Plain text strings are expensive in byte-count.
struct dynamic_headers FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef dynamic_headersT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return dynamic_headersTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "smf.rpc.dynamic_headers";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<header_kv>> *values() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<header_kv>> *>(VT_VALUES);
  }
  flatbuffers::Vector<flatbuffers::Offset<header_kv>> *mutable_values() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<header_kv>> *>(VT_VALUES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           verifier.VerifyVectorOfTables(values()) &&
           verifier.EndTable();
  }
  dynamic_headersT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(dynamic_headersT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<dynamic_headers> Pack(flatbuffers::FlatBufferBuilder &_fbb, const dynamic_headersT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct dynamic_headersBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_values(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<header_kv>>> values) {
    fbb_.AddOffset(dynamic_headers::VT_VALUES, values);
  }
  explicit dynamic_headersBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  dynamic_headersBuilder &operator=(const dynamic_headersBuilder &);
  flatbuffers::Offset<dynamic_headers> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<dynamic_headers>(end);
    return o;
  }
};

inline flatbuffers::Offset<dynamic_headers> Createdynamic_headers(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<header_kv>>> values = 0) {
  dynamic_headersBuilder builder_(_fbb);
  builder_.add_values(values);
  return builder_.Finish();
}

inline flatbuffers::Offset<dynamic_headers> Createdynamic_headersDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<header_kv>> *values = nullptr) {
  auto values__ = values ? _fbb.CreateVector<flatbuffers::Offset<header_kv>>(*values) : 0;
  return smf::rpc::Createdynamic_headers(
      _fbb,
      values__);
}

flatbuffers::Offset<dynamic_headers> Createdynamic_headers(flatbuffers::FlatBufferBuilder &_fbb, const dynamic_headersT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct null_typeT : public flatbuffers::NativeTable {
  typedef null_type TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "smf.rpc.null_typeT";
  }
  null_typeT() {
  }
};

inline bool operator==(const null_typeT &, const null_typeT &) {
  return true;
}

/// \brief, useful when the type is empty
/// i.e.: void foo();
/// rpc my_rpc { null_type MutateOnlyOnServerMethod(int); }
///
struct null_type FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef null_typeT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return null_typeTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "smf.rpc.null_type";
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  null_typeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(null_typeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<null_type> Pack(flatbuffers::FlatBufferBuilder &_fbb, const null_typeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct null_typeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit null_typeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  null_typeBuilder &operator=(const null_typeBuilder &);
  flatbuffers::Offset<null_type> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<null_type>(end);
    return o;
  }
};

inline flatbuffers::Offset<null_type> Createnull_type(
    flatbuffers::FlatBufferBuilder &_fbb) {
  null_typeBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<null_type> Createnull_type(flatbuffers::FlatBufferBuilder &_fbb, const null_typeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline header_kvT *header_kv::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new header_kvT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void header_kv::UnPackTo(header_kvT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = hdr_key(); if (_e) _o->hdr_key = _e->str(); };
  { auto _e = hdr_value(); if (_e) { _o->hdr_value.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->hdr_value[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<header_kv> header_kv::Pack(flatbuffers::FlatBufferBuilder &_fbb, const header_kvT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return Createheader_kv(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<header_kv> Createheader_kv(flatbuffers::FlatBufferBuilder &_fbb, const header_kvT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const header_kvT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _hdr_key = _fbb.CreateString(_o->hdr_key);
  auto _hdr_value = _fbb.CreateVector(_o->hdr_value);
  return smf::rpc::Createheader_kv(
      _fbb,
      _hdr_key,
      _hdr_value);
}

inline dynamic_headersT *dynamic_headers::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new dynamic_headersT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void dynamic_headers::UnPackTo(dynamic_headersT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = values(); if (_e) { _o->values.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->values[_i] = std::unique_ptr<header_kvT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<dynamic_headers> dynamic_headers::Pack(flatbuffers::FlatBufferBuilder &_fbb, const dynamic_headersT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return Createdynamic_headers(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<dynamic_headers> Createdynamic_headers(flatbuffers::FlatBufferBuilder &_fbb, const dynamic_headersT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const dynamic_headersT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _values = _fbb.CreateVector<flatbuffers::Offset<header_kv>> (_o->values.size(), [](size_t i, _VectorArgs *__va) { return Createheader_kv(*__va->__fbb, __va->__o->values[i].get(), __va->__rehasher); }, &_va );
  return smf::rpc::Createdynamic_headers(
      _fbb,
      _values);
}

inline null_typeT *null_type::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new null_typeT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void null_type::UnPackTo(null_typeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<null_type> null_type::Pack(flatbuffers::FlatBufferBuilder &_fbb, const null_typeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return Createnull_type(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<null_type> Createnull_type(flatbuffers::FlatBufferBuilder &_fbb, const null_typeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const null_typeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return smf::rpc::Createnull_type(
      _fbb);
}

inline const flatbuffers::TypeTable *compression_flagsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    compression_flagsTypeTable
  };
  static const char * const names[] = {
    "none",
    "disabled",
    "zstd",
    "lz4"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 4, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *header_bitflagsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    header_bitflagsTypeTable
  };
  static const int64_t values[] = { 1 };
  static const char * const names[] = {
    "has_dynamic_headers"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 1, type_codes, type_refs, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *headerTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 1 },
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    compression_flagsTypeTable,
    header_bitflagsTypeTable
  };
  static const int64_t values[] = { 0, 1, 2, 4, 8, 12, 16, 20 };
  static const char * const names[] = {
    "compression",
    "bitflags",
    "session",
    "size",
    "checksum",
    "meta",
    "dynamic_headers_size"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 7, type_codes, type_refs, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *header_kvTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_CHAR, 1, -1 }
  };
  static const char * const names[] = {
    "hdr_key",
    "hdr_value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *dynamic_headersTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    header_kvTypeTable
  };
  static const char * const names[] = {
    "values"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *null_typeTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *failure_specTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const int64_t values[] = { 0, 4, 5, 6, 8 };
  static const char * const names[] = {
    "delay_duration_ms",
    "delay",
    "terminate",
    "exception"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 4, type_codes, nullptr, values, names
  };
  return &tt;
}

}  // namespace rpc
}  // namespace smf

#endif  // FLATBUFFERS_GENERATED_RPC_SMF_RPC_H_
